/*
 * Copyright (c) 2022
 *      libchewing Core Team. See ChangeLog for details.
 *
 * See the file "COPYING" for information on usage and redistribution
 * of this file.
 */

#ifndef chewing_internal_bindings_h
#define chewing_internal_bindings_h

#pragma once

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include "chewing_public.h"

#define MAX_UTF8_SIZE 4

#define MAX_UTF8_BUF (MAX_UTF8_SIZE + 1)

#define BOPOMOFO_SIZE 4

#define MAX_BOPOMOFO_UTF8_BUF ((BOPOMOFO_SIZE * MAX_UTF8_SIZE) + 1)

#define PINYIN_SIZE 10

#define MAX_PHRASE_LEN 11

#define MAX_PHRASE_UTF8_BUF ((MAX_PHRASE_LEN * MAX_UTF8_SIZE) + 1)

#define MAX_PHONE_SEQ_LEN 50

#define MAX_PHONE_SEQ_BUF (MAX_PHONE_SEQ_LEN + 1)

#define MAX_PHONE_SEQ_UTF8_BUF ((MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE) + 1)

#define MIN_CHI_SYMBOL_LEN 0

#define MAX_CHI_SYMBOL_LEN (MAX_PHONE_SEQ_LEN - MAX_PHRASE_LEN)

#define MAX_INTERVAL (((MAX_PHONE_SEQ_LEN + 1) * MAX_PHONE_SEQ_LEN) / 2)

#define MAX_CHOICE 567

#define MAX_CHOICE_BUF 50

#define EASY_SYMBOL_KEY_TAB_LEN 36

#define AUX_PREFIX_LEN 3

#define MAX_SHOW_MSG_BUF ((MAX_UTF8_SIZE * (MAX_PHRASE_LEN + AUX_PREFIX_LEN)) + 1)

#define N_HASH_BIT 14

#define HASH_TABLE_SIZE (1 << N_HASH_BIT)

#define WORD_CHOICE 0

#define SYMBOL_CATEGORY_CHOICE 1

#define SYMBOL_CHOICE_INSERT 2

#define SYMBOL_CHOICE_UPDATE 3

typedef enum BOPOMOFO {
  BOPOMOFO_IGNORE,
  BOPOMOFO_ABSORB,
  BOPOMOFO_COMMIT,
  BOPOMOFO_KEY_ERROR,
  BOPOMOFO_ERROR,
  BOPOMOFO_NO_WORD,
  BOPOMOFO_OPEN_SYMBOL_TABLE,
} BOPOMOFO;

typedef enum Category {
  CHEWING_NONE,
  CHEWING_CHINESE,
  CHEWING_SYMBOL,
} Category;

typedef enum KBTYPE {
  KBTYPE_STANDARD,
  KBTYPE_HSU,
  KBTYPE_IBM,
  KBTYPE_GIN_YIEH,
  KBTYPE_ET,
  KBTYPE_ET26,
  KBTYPE_DVORAK,
  KBTYPE_DVORAK_HSU,
  KBTYPE_DACHEN_CP26,
  KBTYPE_HANYU_PINYIN,
  KBTYPE_LUOMA_PINYIN,
  KBTYPE_MSP2,
  KBTYPE_CARPALX,
  KBTYPE_COUNT,
} KBTYPE;

typedef enum KeyBehavior {
  IGNORE = 0,
  ABSORB,
  COMMIT,
  KEY_ERROR,
  ERROR,
  NO_WORD,
  OPEN_SYMBOL_TABLE,
} KeyBehavior;

typedef enum KeyboardLayoutCompat {
  DEFAULT = 0,
  HSU,
  IBM,
  GIN_YIEH,
  ET,
  ET26,
  DVORAK,
  DVORAK_HSU,
  DACHEN_CP26,
  HANYU_PINYIN,
  THL_PINYIN,
  MPS2_PINYIN,
  CARPALX,
} KeyboardLayoutCompat;

typedef struct ChewingConversionEngine ChewingConversionEngine;

typedef struct RefCell_LayeredDictionary RefCell_LayeredDictionary;

typedef struct SyllableEditorWithKeymap SyllableEditorWithKeymap;

typedef struct AvailInfoAvail {
  int len;
  const void *id;
} AvailInfoAvail;

/**
 * Information of available phrase or character choices.
 */
typedef struct AvailInfo {
  /**
   * All kinds of lengths of available phrases.
   */
  struct AvailInfoAvail avail[MAX_PHRASE_LEN];
  /**
   * Total number of available lengths.
   */
  int nAvail;
  /**
   * The current choosing available length.
   */
  int currentAvail;
} AvailInfo;

typedef struct ChoiceInfo {
  /**
   * Total page number.
   */
  int nPage;
  /**
   * Current page number.
   */
  int pageNo;
  /**
   * Number of choices per page.
   */
  int nChoicePerPage;
  /**
   * Store possible phrases for being chosen.
   */
  char totalChoiceStr[MAX_CHOICE][MAX_PHRASE_UTF8_BUF];
  /**
   * Number of phrases to choose.
   */
  int nTotalChoice;
  int oldChiSymbolCursor;
  int isSymbol;
} ChoiceInfo;

typedef struct PhrasingOutput {
  IntervalType dispInterval[MAX_INTERVAL];
  int nDispInterval;
  int nNumCut;
} PhrasingOutput;

typedef struct BopomofoData {
  struct SyllableEditorWithKeymap *editorWithKeymap;
} BopomofoData;

typedef struct PreeditBuf {
  enum Category category;
  uint8_t char_[MAX_UTF8_BUF];
} PreeditBuf;

typedef struct UserPhraseData {
  uint16_t phoneSeq[MAX_PHONE_SEQ_LEN];
  char wordSeq[MAX_PHRASE_UTF8_BUF];
  int userfreq;
  int recentTime;
  int origfreq;
  int maxfreq;
} UserPhraseData;

typedef struct SymbolEntry {
  /**
   * Total number of symbols in the category.
   *
   * If n_symbols = 0, the category is treat as a symbol,
   * which is a zero-terminated utf-8 string.
   *
   * In that case, `symbols` is unused and isn't allocated at all.
   */
  int nSymbols;
  /**
   * Category name of the symbols.
   */
  char category[MAX_PHRASE_UTF8_BUF];
  char symbols[0][MAX_UTF8_BUF];
} SymbolEntry;

typedef struct ChewingStaticData {
  unsigned int nSymbolEntry;
  struct SymbolEntry **symbolTable;
  char *gEasySymbolValue[EASY_SYMBOL_KEY_TAB_LEN];
  int gEasySymbolNum[EASY_SYMBOL_KEY_TAB_LEN];
  void *userphraseIter;
} ChewingStaticData;

typedef struct ChewingData {
  struct AvailInfo availInfo;
  struct ChoiceInfo choiceInfo;
  struct PhrasingOutput phrOut;
  struct BopomofoData bopomofoData;
  ChewingConfigData config;
  /**
   * Current input buffer, content == 0 means Chinese code
   */
  struct PreeditBuf preeditBuf[MAX_PHONE_SEQ_LEN];
  int chiSymbolCursor;
  int chiSymbolBufLen;
  int pointStart;
  int pointEnd;
  int bShowMsg;
  char showMsg[MAX_SHOW_MSG_BUF];
  int showMsgLen;
  uint16_t phoneSeq[MAX_PHONE_SEQ_LEN];
  uint16_t phoneSeqAlt[MAX_PHONE_SEQ_LEN];
  int nPhoneSeq;
  char selectStr[MAX_PHONE_SEQ_LEN][MAX_PHRASE_UTF8_BUF];
  IntervalType selectInterval[MAX_PHONE_SEQ_LEN];
  int nSelect;
  IntervalType preferInterval[MAX_INTERVAL];
  int nPrefer;
  int bUserArrCnnct[MAX_PHONE_SEQ_BUF];
  int bUserArrBrkpt[MAX_PHONE_SEQ_BUF];
  int bArrBrkpt[MAX_PHONE_SEQ_BUF];
  int bSymbolArrBrkpt[MAX_PHONE_SEQ_BUF];
  int bChiSym;
  int bSelect;
  int bFirstKey;
  int bFullShape;
  char symbolKeyBuf[MAX_PHONE_SEQ_LEN];
  struct UserPhraseData userphraseData;
  struct ChewingStaticData staticData;
  void (*logger)(void *data, int level, const char *fmt);
  void *loggerData;
  const void *dict;
  void *ce;
  void *ue;
} ChewingData;

typedef struct Phrase {
  char phrase[MAX_PHONE_SEQ_BUF];
  int freq;
} Phrase;

typedef struct ChewingOutput {
  /**
   * The content of edit buffer
   */
  char preeditBuf[MAX_PHONE_SEQ_UTF8_BUF];
  /**
   * The length of edit buffer
   */
  int chiSymbolBufLen;
  /**
   * The current position of the cursor
   */
  long chiSymbolCursor;
  long pointStart;
  long pointEnd;
  char bopomofoBuf[MAX_BOPOMOFO_UTF8_BUF];
  IntervalType dispInterval[MAX_INTERVAL];
  int nDispInterval;
  int dispBrkpt[MAX_PHONE_SEQ_BUF];
  char commitBuf[MAX_PHONE_SEQ_UTF8_BUF];
  int commitBufLen;
  struct ChoiceInfo *pci;
  int bChiSym;
  int selKey[MAX_SELKEY];
  int keystrokeRtn;
} ChewingOutput;

typedef struct ChewingContext {
  struct ChewingData *data;
  struct ChewingOutput *output;
  int candNo;
  int itNo;
  int kbNo;
} ChewingContext;

extern int toPreeditBufIndex(struct ChewingData *pgdata, int pos);

extern int HaninSymbolInput(struct ChewingData *pgdata);

struct SyllableEditorWithKeymap *NewPhoneticEditor(enum KeyboardLayoutCompat kb_type);

void FreePhoneticEditor(struct SyllableEditorWithKeymap *editor_keymap_ptr);

enum KeyBehavior BopomofoPhoInput(struct ChewingData *data_ptr, int32_t key);

void BopomofoPhoInx(struct BopomofoData *data_ptr, int32_t *pho_inx);

void BopomofoPhoInxAlt(struct BopomofoData *data_ptr, int32_t *pho_inx);

void BopomofoKeyseq(struct BopomofoData *data_ptr, char *key_seq);

uint16_t BopomofoSyllableIndex(struct BopomofoData *data_ptr);

uint16_t BopomofoSyllableIndexAlt(struct BopomofoData *data_ptr);

int BopomofoRemoveLast(struct BopomofoData *data_ptr);

int BopomofoRemoveAll(struct BopomofoData *data_ptr);

int BopomofoKbType(struct BopomofoData *data_ptr);

int BopomofoIsEntering(struct BopomofoData *data_ptr);

struct ChewingConversionEngine *InitConversionEngine(const struct RefCell_LayeredDictionary *dict_ptr);

void TerminateConversionEngine(struct ChewingConversionEngine *ce_ptr);

void ConversionEngineDoPhrasing(void *pgdata,
                                struct ChewingConversionEngine *ce_ptr,
                                uint16_t *syllables_u16_ptr,
                                uintptr_t syllables_len,
                                char (*select_strs_ptr)[MAX_PHRASE_UTF8_BUF],
                                IntervalType *select_intervals_ptr,
                                uintptr_t select_len,
                                int *breaks_u16_ptr,
                                uintptr_t breaks_len,
                                IntervalType *display_intervals_ptr,
                                int *display_intervals_len);

bool IsIntersect(IntervalType in1, IntervalType in2);

const void *InitDict(char *prefix);

void TerminateDict(const void *dict_ptr);

void *GetCharFirst(const void *dict_ptr, struct Phrase *phrase_ptr, uint16_t syllable_u16);

void *GetPhraseFirst(void *vec_ptr, struct Phrase *phrase_ptr);

void *TreeFindPhrase(const void *dict_ptr, int begin, int end, uint16_t *syllables_u16);

void *GetVocabNext(void *iter_ptr, struct Phrase *phrase_ptr);

char *GetDefaultUserPhrasePath(void *_data);

void FreeDefaultUserPhrasePath(char *path);

void *InitUserphrase(char *path);

void TerminateUserphrase(void *ptr);

void *UserGetPhraseFirst(void *ue_ptr, void *userphrase_data_ptr, uint16_t *syllables_u16_ptr);

void *UserGetPhraseNext(void *iter_ptr, void *userphrase_data_ptr);

uint8_t UserUpdatePhrase(void *ue_ptr, uint16_t *syllables_u16_ptr, char *phrase_str_ptr);

bool UserRemovePhrase(void *ue_ptr, uint16_t *syllables_u16_ptr, char *phrase_str_ptr);

void IncreaseLifeTime(void *ue_ptr);

void UserUpdatePhraseBegin(void*);

void UserGetPhraseEnd(void*, void*);

void *UserEnumeratePhrase(void *ue_ptr);

bool UserEnumerateHasNext(void *iter_ptr, unsigned int *phrase_len_ptr, unsigned int *bopomofo_len);

int UserEnumerateGet(void *iter_ptr,
                     char *phrase_buf,
                     const unsigned int *_phrase_len_ptr,
                     char *bopomofo_buf,
                     const unsigned int *_bopomofo_len);

#endif /* chewing_internal_bindings_h */
